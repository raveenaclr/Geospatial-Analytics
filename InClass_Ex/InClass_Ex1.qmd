---
title: "Spatial Weights and Applications"
---

### 1. Quick Recap

In previous sections we have seen how to

-   extract geospatial and aspatial datasets

-   convert one projection to another

-   perform exploratory data analysis

-   create choropleth map using tmap's elements and leverage its aesthetics

### 2. Introduction

Spatial statistics integrate space and spatial relationships directly into their mathematics (area, distance, length, or proximity, for example). Typically, these spatial relationships are defined formally through values called spatial weights. Spatial weights are structured into a spatial weights matrix and stored as a [spatial weights matrix file](https://pro.arcgis.com/en/pro-app/3.0/tool-reference/spatial-statistics/modeling-spatial-relationships.htm#GUID-516F26AF-583B-4918-AB13-0DBEA946F072). Spatial weights are a way to define spatial neighbourhood. One practical use case can be - Are these two planning zones neighbours? They can be determined by either contiguity neighbours - rook / hexagon / queen or adjacency based neighbours - weight matrix

![](images/spatial%20weights.PNG){fig-align="center"}

### 3. Glimpse of Steps

Some of the important steps performed in this study are as follows

-   importing geospatial data using appropriate function(s) of **sf** package,

-   importing csv file using appropriate function of **readr** package,

-   performing relational join using appropriate join function of **dplyr** package,

-   computing spatial weights using appropriate functions of **spdep** package, and

-   calculating spatially lagged variables using appropriate functions of **spdep** package.

### 4. Data

Following two data sets are used:

-   Hunan county boundary layer. This is a geospatial data set in ESRI shapefile format.

-   Hunan_2012.csv: This csv file contains selected Hunan's local development indicators in 2012.

### 5. Deep Dive into Map Analysis

#### 5.1 Installing libraries and Importing files

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse)
hunan <- st_read(dsn = "data/geospatial", 
                 layer = "Hunan")
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
```

#### 5.2 Data Wrangling

```{r}
hunan <- left_join(hunan,hunan2012)
```

#### 5.3 Visualising Regional Development Indicator

```{r}
basemap <- tm_shape(hunan) +
  tm_polygons() +
  tm_text("NAME_3", size=0.5)

gdppc <- qtm(hunan, "GDPPC")
tmap_arrange(basemap, gdppc, asp=1, ncol=2)
```

#### 5.4 Computing Contiguity Spatial Weights

##### 5.4.1 Computing (QUEEN) contiguity based neighbours

```{r}
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```

```{r}
wm_q[[1]]
hunan$County[1]
hunan$NAME_3[c(2,3,4,57,85)]
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1
```

##### 5.4.2 Creating (ROOK) contiguity based neighbours

```{r}
wm_r <- poly2nb(hunan, queen=FALSE)
summary(wm_r)

```

##### 5.4.3 Visualising contiguity weights

```{r}
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
coords <- cbind(longitude, latitude)
```

##### 5.4.4 Plotting Queen contiguity based neighbours map

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
```

##### 5.4.5 Plotting Rook contiguity based neighbours map

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

##### 5.4.6 Plotting both Queen and Rook contiguity based neighbours maps

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red", main="Queen Contiguity")
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red", main="Rook Contiguity")
```

#### 5.5 Computing distance based neighbours

##### 5.5.1 Determine the cut-off distance

```{r}
#coords <- coordinates(hunan)
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

##### 5.5.2 Computing fixed distance weight matrix

```{r}
wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
wm_d62
```

##### 5.5.3 Plotting fixed distance weight matrix

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE)
plot(k1, coords, add=TRUE, col="red", length=0.08)
```

**Alternative Approach**

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey")
plot(k1, coords, add=TRUE, col="red", length=0.08, main="1st nearest neighbours")
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6, main="Distance link")
```

##### 5.5.4 Computing adaptive distance weight matrix

```{r}
knn6 <- knn2nb(knearneigh(coords, k=6))
knn6

```

##### 5.5.5 Plotting distance based neighbours

```{r}
plot(hunan$geometry, border="lightgrey")
plot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

#### 5.6 Weights based on IDW

```{r}
dist <- nbdists(wm_q, coords, longlat = TRUE)
ids <- lapply(dist, function(x) 1/(x))
ids
```

##### 5.6.1 Row-standardised weights matrix

```{r}
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q
rswm_q$weights[10]
rswm_ids <- nb2listw(wm_q, glist=ids, style="B", zero.policy=TRUE)
rswm_ids
rswm_ids$weights[1]
summary(unlist(rswm_ids$weights))
```

#### 5.7 Application of Spatial Weight Matrix

##### 5.7.1 Spatial lag with row-standardized weights

```{r}
GDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)
GDPPC.lag
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1
lag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))
lag.res <- as.data.frame(lag.list)
colnames(lag.res) <- c("NAME_3", "lag GDPPC")
hunan <- left_join(hunan,lag.res)

```

##### 5.7.2 Comparing GDPPC and spatial lag GDPPC maps

```{r}
gdppc <- qtm(hunan, "GDPPC")
lag_gdppc <- qtm(hunan, "lag GDPPC")
tmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)
```

##### 5.7.3 Spatial lag as a sum of neighboring values

```{r}
b_weights <- lapply(wm_q, function(x) 0*x + 1)
b_weights2 <- nb2listw(wm_q, 
                       glist = b_weights, 
                       style = "B")
b_weights2

lag_sum <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))
lag.res <- as.data.frame(lag_sum)
colnames(lag.res) <- c("NAME_3", "lag_sum GDPPC")

```

##### 5.7.4  Comparing *GDPPC* and *Spatial Lag Sum GDPPC* maps

```{r}
hunan <- left_join(hunan, lag.res)
gdppc <- qtm(hunan, "GDPPC")
lag_sum_gdppc <- qtm(hunan, "lag_sum GDPPC")
tmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)
```

##### 5.7.5  Spatial window average

```{r}
wm_q1 <- wm_q
include.self(wm_q1)
wm_q1 <- nb2listw(wm_q1)
wm_q1
lag_w_avg_gpdpc <- lag.listw(wm_q1, 
                             hunan$GDPPC)
lag_w_avg_gpdpc
lag.list.wm_q1 <- list(hunan$NAME_3, lag.listw(wm_q1, hunan$GDPPC))
lag_wm_q1.res <- as.data.frame(lag.list.wm_q1)
colnames(lag_wm_q1.res) <- c("NAME_3", "lag_window_avg GDPPC")
hunan <- left_join(hunan, lag_wm_q1.res)

```

##### 5.7.6 Comparing GDPPC and lag_window_avg GDPPC maps

```{r}
gdppc <- qtm(hunan, "GDPPC")
w_avg_gdppc <- qtm(hunan, "lag_window_avg GDPPC")
tmap_arrange(gdppc, w_avg_gdppc, asp=1, ncol=2)
```

##### 5.7.7 Spatial window sum

```{r}
wm_q1 <- wm_q
include.self(wm_q1)
wm_q1
b_weights <- lapply(wm_q1, function(x) 0*x + 1)
b_weights[1]
b_weights2 <- nb2listw(wm_q1, 
                       glist = b_weights, 
                       style = "B")
b_weights2
w_sum_gdppc <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))
w_sum_gdppc
w_sum_gdppc.res <- as.data.frame(w_sum_gdppc)
colnames(w_sum_gdppc.res) <- c("NAME_3", "w_sum GDPPC")
hunan <- left_join(hunan, w_sum_gdppc.res)

```

##### 5.7.8 Comparing GDPPC and lag_sum GDPPC maps

```{r}
gdppc <- qtm(hunan, "GDPPC")
w_sum_gdppc <- qtm(hunan, "w_sum GDPPC")
tmap_arrange(gdppc, w_sum_gdppc, asp=1, ncol=2)
```

### 6. Conclusion & Key Takeaways

### 7. References










